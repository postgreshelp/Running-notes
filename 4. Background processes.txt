/usr/pgsql-17/bin/postgres -D /u01/pgsql/data
	
- establish a session
- take care of other background procesess
- instance recovery

postgres: logger

- records every event happening in your instance to log file

# REPORTING AND LOGGING

# - Where to Log -	where do you want me to log information?
log_destination = 'stderr'
logging_collector = on

log_directory = 'log' 
--> log_directory = '/u01/logs/' 
                                                      
log_filename = 'postgresql-%a.log'   
--> log_filename = 'postgresql-%d-%m-%y.log' 
                             
log_rotation_age = 1d   ##ignore.,           
log_rotation_size = 0   ##ignore.,


# - When to Log - How much information you want?
log_min_messages = debug2       	    # values in order of decreasing detail:
                                        #   debug5
                                        #   debug4
                                        #   debug3
                                        #   debug2
                                        #   debug1
                                        #   info
                                        #   notice
                                        #   warning
                                        #   error
                                        #   log
                                        #   fatal
                                        #   panic


# - What to Log - What kind of information you want?
#log_checkpoints = on
#log_connections = off         #from where connection came, client ip, connection to which user etc.,
#log_disconnections = off
#log_duration = off
#log_error_verbosity = default   
#log_hostname = off
#log_autovacuum_min_duration = 10min

postgres: walwriter
-> on every commit, wal writer will write information from wal buffers to wal files

postgres: checkpointer
-> Ensures your dirty buffers are written to datafiles.

checkpoint_timeout = 5m

postgres: background writer
-> writes information from shared buffers to disk

bgwriter_delay = 200ms
bgwriter_lru_maxpages = 100

###### information in your shared buffers is written to diks by

	1. bgwriter
	2. checkpointer

postgres: autovacuum launcher

   - clean up dead tuples.
   - gather statistics.
   - solves transaction ID wraparound problem. (freeze old txids)
   ..
   ..
	
	
autovacuum_work_mem = -1              
log_autovacuum_min_duration = 10min   
autovacuum = on                       
autovacuum_max_workers = 3            
autovacuum_naptime = 1min  
       	   
autovacuum_vacuum_threshold = 50  
autovacuum_vacuum_scale_factor = 0.2  

threshold -> autovacuum_vacuum_threshold + autovacuum_vacuum_scale_factor*no.of records.
1000 records.,

		  -> 50 + 0.2*1000  -> 50+200 => 250

autovacuum_analyze_threshold = 50     
autovacuum_analyze_scale_factor = 0.1 

		  -> 50+0.1*1000 -> 50+100 -> 150

autovacuum_vacuum_insert_threshold = 1000    
autovacuum_vacuum_insert_scale_factor = 0.2    

		   -> 1000+0.2*1000 -> 1000+200 -> 1200
		   	   
autovacuum_freeze_max_age = 200000000 (10% of 2 Billion)
  
  
transaction ID wraparound

	- is a situation where your transaction id percentage reaching 100% (2 billion)
	- postgres has inbuilt mechanism for it to not reach 100% (vacuum freeze)
	- freezing begins at 10%
	
	Reasons why your postgres ignore 10% limit..
	
	- your freezing rate is slower than transaction rate.**
	- your long running query. (99.99%)
	- your long running query in replica.
	- invalid replication slots.*
	- prepared transactions*
  
Query to monitor:

WITH max_age AS (
    SELECT 2000000000 as max_old_xid
        , setting AS autovacuum_freeze_max_age
        FROM pg_catalog.pg_settings
        WHERE name = 'autovacuum_freeze_max_age' )
, per_database_stats AS (
    SELECT datname
        , m.max_old_xid::int
        , m.autovacuum_freeze_max_age::int
        , age(d.datfrozenxid) AS oldest_current_xid
    FROM pg_catalog.pg_database d
    JOIN max_age m ON (true)
    WHERE d.datallowconn )
SELECT max(oldest_current_xid) AS oldest_current_xid
    , max(ROUND(100*(oldest_current_xid/max_old_xid::float))) AS percent_towards_wraparound
    , max(ROUND(100*(oldest_current_xid/autovacuum_freeze_max_age::float))) AS percent_towards_emergency_autovac
FROM per_database_stats

 oldest_current_xid | percent_towards_wraparound | percent_towards_emergency_autovac
--------------------+----------------------------+-----------------------------------
          122123167 |                         09 |                                99
	
  
autovacuum_vacuum_cost_delay = 2ms                                
autovacuum_vacuum_cost_limit = 200   (use vacuum_cost_limit)

best practices
-----------------

1. run manual vacuum every day (during non business hours)

2. still don't stop autovacuum.

3. you can adjust/disable vacuum parameters on any table.   
ALTER TABLE emp SET ( autovacuum_enabled = false );  

4. make delayed/aggressive vacuum on a table by adjusting table level settings.
ALTER TABLE emp SET ( autovacuum_vacuum_threshold = 100000 );

5. run vacuum full during maintenance periods.

6. keep an eye on TxID utilization. (not be greater than 50)

Few commands
--------------

postgres=#
postgres=# vacuum emp;
VACUUM
postgres=# vacuum (freeze) emp;
VACUUM
postgres=# analyze emp;
ANALYZE
postgres=# vacuum (analyze) emp;
VACUUM
postgres=# vacuum (analyze, freeze) emp;
VACUUM
postgres=# vacuum full emp;
VACUUM
postgres=# analyze;
ANALYZE
postgres=# vacuum ;
VACUUM
postgres=# vacuum full;
VACUUM
postgres=#

